<?php
require_once __DIR__ . '/../db_core/db_engine.php';

/**
 * Prepare and execute a SELECT, returning all rows.
 *
 * @param string               $sql     The SQL statement to execute.
 * @param array<int|string,mixed> $params  Bound parameters (named or positional).
 *
 * @return array<int,array<string,mixed>>
 */
function db_all(string $sql, array $params = []): array
{
  $st = db()->prepare($sql);
  foreach ($params as $k => $v) {
    $name = is_int($k) ? $k + 1 : (str_starts_with($k, ':') ? $k : ":$k");
    $type = is_int($v) ? PDO::PARAM_INT : PDO::PARAM_STR;
    $st->bindValue($name, $v, $type);
  }
  $st->execute();
  return $st->fetchAll();
}

/**
 * Execute a SELECT and return the first row or null when none are found.
 *
 * @param string               $sql
 * @param array<int|string,mixed> $params
 *
 * @return array<string,mixed>|null
 */
function db_one(string $sql, array $params = []): ?array
{
  $rows = db_all($sql, $params);
  return $rows[0] ?? null;
}

/**
 * Execute a data-changing statement (INSERT/UPDATE/DELETE).
 *
 * @param string               $sql
 * @param array<int|string,mixed> $params
 *
 * @return int Rows affected.
 */
function db_exec(string $sql, array $params = []): int
{
  $st = db()->prepare($sql);
  foreach ($params as $k => $v) {
    $name = is_int($k) ? $k + 1 : (str_starts_with($k, ':') ? $k : ":$k");
    $type = is_int($v) ? PDO::PARAM_INT : PDO::PARAM_STR;
    $st->bindValue($name, $v, $type);
  }
  $st->execute();
  return $st->rowCount();
}

/**
 * Resolve page, limit, and offset from a query array using global defaults.
 *
 * @param array<string,mixed> $q
 *
 * @return array{0:int,1:int,2:int} [limit, offset, page]
 */
function page_resolve(array $q): array
{
  $sizes   = defined('PAGE_SIZES') ? PAGE_SIZES : [25, 50, 100];
  $default = defined('DEFAULT_PAGE_SIZE') ? DEFAULT_PAGE_SIZE : 25;
  $size = isset($q['size']) && in_array((int)$q['size'], $sizes, true) ? (int)$q['size'] : $default;
  $page = max(1, (int)($q['page'] ?? 1));
  $offset = ($page - 1) * $size;
  return [$size, $offset, $page];
}

/**
 * Build a WHERE clause and parameter map from user-provided filters.
 *
 * @param array<string,mixed>        $filters Filter values (usually guarded request input).
 * @param array<string,array{0:string,1?:callable(mixed):mixed}> $map Map of filter key => [sqlClause, transform?].
 *
 * @return array{0:string,1:array<string,mixed>} [whereSql, params]
 */
function sql_filters(array $filters, array $map): array
{
  $clauses = [];
  $params  = [];

  foreach ($map as $key => $tpl) {
    // $tpl should be: [sqlString, optionalTransformCallable]
    if (!array_key_exists($key, $filters) || $filters[$key] === '' || $filters[$key] === null) {
      continue;
    }

    $sql = $tpl[0] ?? '';
    $xf  = $tpl[1] ?? null;

    $val = $filters[$key];
    if (is_callable($xf)) {
      $val = $xf($val);
    }

    if ($sql === '') {
      continue; // skip malformed map entries
    }

    $clauses[] = $sql;

    // Extract the first named param from the clause (assumes one per clause)
    if (preg_match('/:(\w+)/', $sql, $m)) {
      $params[$m[1]] = $val;
    }
  }

  $where = $clauses ? ('WHERE ' . implode(' AND ', $clauses)) : '';
  return [$where, $params];
}


/**
 * Execute a paginated query and return rows plus metadata.
 *
 * @param string               $baseSql  SELECT statement without WHERE/LIMIT.
 * @param string               $countSql COUNT(*) statement matching the base joins.
 * @param string               $where    WHERE clause generated by {@see sql_filters}.
 * @param string               $orderBy  ORDER BY clause for deterministic paging.
 * @param array<string,mixed>  $params   Parameters produced by {@see sql_filters}.
 * @param int                  $page     1-indexed page number.
 * @param int                  $size     Page size.
 *
 * @return array{rows:array<int,array<string,mixed>>,total:int,page:int,size:int}
 */
function db_paged(string $baseSql, string $countSql, string $where, string $orderBy, array $params, int $page, int $size): array
{
  $limitSql = trim($orderBy . ' LIMIT :limit OFFSET :offset');
  $rows = db_all(
    "$baseSql $where $limitSql",
    array_merge($params, ['limit' => $size, 'offset' => ($page - 1) * $size])
  );
  $cnt  = db_one("$countSql $where", $params);
  $total = (int)($cnt['c'] ?? 0);
  return ['rows' => $rows, 'total' => $total, 'page' => $page, 'size' => $size];
}
